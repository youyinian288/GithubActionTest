# Workflow(Action) 名称
name: CI-Testing

# Actions 日志的标题名称（PR标题或分支名）
run-name: "[CI-Testing] ${{ github.event.pull_request.title || github.ref }}"

# 并发控制：同组任务有新触发时，取消正在运行的旧任务
# 避免多次提交导致的资源浪费（如连续push时）
concurrency:
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# 触发事件配置
on:
  # PR相关事件触发
  pull_request:
    # 触发时机：PR创建、重新打开、有新提交时
    types: [opened, synchronize, reopened]
  # 手动触发（可通过GitHub界面选择参数）
  workflow_dispatch:
    inputs:
      # 要执行的Fastlane测试任务
      TEST_LANE:
        description: '测试任务（Fastlane Lane）'
        default: 'run_unit_tests'
        type: choice
        options:
          - run_unit_tests  # 仅运行单元测试
          - run_all_tests   # 运行所有测试
  # 允许被其他工作流调用（如夜间构建）
  workflow_call:
    inputs:
      # 测试任务（无choice类型，兼容workflow_call）
      TEST_LANE:
        description: '测试任务（Fastlane Lane）'
        default: 'run_unit_tests'
        type: string
      # 要检查的分支
      BRANCH:
        description: '目标分支'
        type: string

# 任务定义（Jobs会并行执行，此处仅一个testing任务）
jobs:
  testing:
    name: 执行测试
    # 运行环境：使用GitHub托管的macOS-15 runner（适合iOS项目）
    # 注意：公共仓库可免费使用，私有仓库按用量计费，建议私有项目使用自托管runner
    runs-on: macos-15
    # 超时时间：防止任务无限挂起（最长30分钟）
    timeout-minutes: 30
    # 默认使用zsh shell（替代默认bash）
    defaults:
      run:
        shell: zsh {0}

    # 权限配置：解决创建check run等操作的权限问题
    permissions:
      checks: write  # 允许创建测试报告check run
      pull-requests: write  # 允许向PR提交评论
      contents: read  # 允许读取仓库代码

    # 步骤定义（按顺序执行）
    steps:
      # 1. 拉取代码到runner
      - name: 拉取仓库代码
        uses: actions/checkout@v4  # 更新到最新v4版本
        with:
          lfs: false  # 不启用Git LFS（项目无需大文件支持）
          #  checkout指定分支（如夜间构建需指定非默认分支时使用）
          ref: ${{ github.event.inputs.BRANCH || '' }}

      # ========== 环境配置步骤 ==========

      # 2. 读取项目指定的Xcode版本（从.ruby-version文件）
      - name: 读取Xcode版本
        id: read_xcode_version
        run: |
          # 从项目根目录的.xcode-version文件读取版本号
          XCODE_VERSION=$(cat .xcode-version)
          echo "检测到Xcode版本: ${XCODE_VERSION}"
          # 输出到GitHub环境变量，供后续步骤使用
          echo "xcode_version=${XCODE_VERSION}" >> $GITHUB_OUTPUT

      # 3. 读取项目指定的Ruby版本（从.ruby-version文件）
      - name: 读取Ruby版本
        id: read_ruby_version
        run: |
          # 从项目根目录的.ruby-version文件读取版本号
          RUBY_VERSION=$(cat .ruby-version)
          echo "检测到Ruby版本: ${RUBY_VERSION}"
          # 输出到GitHub环境变量，供后续步骤使用
          echo "ruby_version=${RUBY_VERSION}" >> $GITHUB_OUTPUT

      # 4. 配置Ruby环境（安装项目指定版本）
      - name: 配置Ruby环境
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "${{ steps.read_ruby_version.outputs.ruby_version }}"  # 使用读取到的版本

      # ========== 缓存配置步骤（加速依赖安装） ==========

      # 5. 缓存Ruby依赖（Gemfile.lock对应依赖）
      - name: 缓存Ruby依赖
        uses: actions/cache@v3
        with:
          path: ./vendor  # 缓存路径（对应bundle config的安装目录）
          # 缓存key：系统+依赖锁文件哈希（锁文件变更时重建缓存）
          key: ${{ runner.os }}-bundle-${{ hashFiles('Gemfile.lock') }}
          # 恢复策略：未命中精确key时，使用最近的旧缓存
          restore-keys: |
            ${{ runner.os }}-bundle-

      # 6. 缓存CocoaPods依赖（Podfile.lock对应依赖）
      - name: 缓存CocoaPods依赖
        uses: actions/cache@v3
        with:
          path: ./Product/Pods  # 项目Pods目录路径
          key: ${{ runner.os }}-cocoapods-${{ hashFiles('Product/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-cocoapods-

      # 7. 缓存Mint工具（Mintfile定义的工具）
      - name: 缓存Mint工具
        uses: actions/cache@v3
        with:
          path: ./mint  # Mint安装路径
          key: ${{ runner.os }}-mint-${{ hashFiles('Mintfile') }}
          restore-keys: |
            ${{ runner.os }}-mint-

      # ========== 依赖安装步骤 ==========

      # 8. 项目初始化与依赖安装
      - name: 初始化项目并安装依赖
        run: |
          # 执行Makefile中的setup指令（如安装Mint、Bundle配置等）
          make setup
          # 执行Makefile中的install指令（如生成Xcode项目、pod install等）
          make install

      # ========== 执行测试步骤 ==========

      # 9. 运行测试（核心步骤）
      - name: 执行测试
        id: testing
        working-directory: ./Product/  # 切换到Product目录执行
        env:
          # 测试任务选择：PR触发时默认仅跑单元测试，其他情况按输入值
          TEST_LANE: ${{ github.event_name == 'pull_request' && 'run_unit_tests' || github.event.inputs.TEST_LANE || 'run_all_tests' }}
          # 指定Xcode路径（使用读取到的版本）
          DEVELOPER_DIR: "/Applications/Xcode_${{ steps.read_xcode_version.outputs.xcode_version }}.app/Contents/Developer"
          # 模拟器配置（从仓库变量读取）
          SIMULATOR_NAME: ${{ vars.SIMULATOR_NAME }}
          SIMULATOR_IOS_VERSION: ${{ vars.SIMULATOR_IOS_VERSION }}
          # 当前runner名称
          RUNNER_NAME: ${{ runner.name }}
          # 延长Xcodebuild超时和重试次数（避免环境波动导致失败）
          FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT: 60
          FASTLANE_XCODEBUILD_SETTINGS_RETRIES: 10
        run: |
          # 关闭立即退出模式（即使命令失败也继续执行后续逻辑）
          set +e
          
          EXIT_CODE=0  # 存储命令退出码（0=成功，非0=失败）
          # 执行Fastlane测试命令，并将输出写入临时文件（用于后续分析）
          bundle exec fastlane ${TEST_LANE} device:"${SIMULATOR_NAME} (${SIMULATOR_IOS_VERSION})" | tee "$RUNNER_TEMP/testing_output.txt"
          # 更新退出码（取fastlane命令的实际退出码）
          [[ $EXIT_CODE -eq 0 ]] && EXIT_CODE=${pipestatus[1]}
          
          # 恢复立即退出模式
          set -e
          
          # 分析输出文件，判断失败类型（构建失败/测试失败）
          if grep -q "Error building" "$RUNNER_TEMP/testing_output.txt"; then
            echo "is_build_error=true" >> $GITHUB_OUTPUT  # 标记为构建失败
            echo "❌ 检测到构建失败"
          elif grep -q "Tests have failed" "$RUNNER_TEMP/testing_output.txt"; then
            echo "is_test_error=true" >> $GITHUB_OUTPUT  # 标记为测试失败
            echo "❌ 检测到测试失败"
          fi
          
          # 退出并返回实际结果码
          exit $EXIT_CODE

      # ========== 结果处理步骤 ==========

      # 10. 发布测试报告（生成JUnit报告并关联到PR）
      - name: 发布测试报告
        # 仅在测试成功或测试失败时执行（构建失败不执行）
        if: ${{ (failure() && steps.testing.outputs.is_test_error == 'true') || success() }}
        uses: mikepenz/action-junit-report@v5
        with:
          check_name: "测试报告"  # 在PR中显示的检查名称
          comment: true  # 向PR提交评论
          updateComment: false  # 不更新旧评论（保留历史）
          require_tests: true  # 必须有测试结果
          detailed_summary: true  # 显示详细摘要
          report_paths: "./Product/fastlane/test_output/*.junit"  # JUnit报告路径

      # 11. 构建失败时向PR提交评论
      - name: 构建失败评论
        # 仅在构建失败且存在PR时执行
        if: ${{ failure() && steps.testing.outputs.is_build_error == 'true' && github.event.pull_request.number }}
        uses: actions/github-script@v6
        env:
          # 工作流运行地址（用于评论中的链接）
          action_url: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}/attempts/${{ github.run_attempt }}"
        with:
          script: |
            const action_url = process.env.action_url
            const pullRequest = context.payload.pull_request || {}
            const commitSha = pullRequest.head?.sha || context.sha  # 提交SHA
            const creator = pullRequest.user?.login || context.actor  # PR创建者
            
            # 评论内容
            const commentBody = [
              `# 项目或测试构建失败 ❌`,
              `请确认您的PR能否正常编译并执行测试。`,
              ``,
              `🔗 **工作流地址**: [查看详情](${action_url})`,
              `📝 **提交**: ${commitSha}`,
              `👤 **作者**: @${creator}`
            ].join('\n')
            
            # 向PR提交评论
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: commentBody
            })